import React, { useEffect, useMemo, useState } from "react";

// RealTimeProgressDashboard.jsx
// Single-file React component, tailwind-friendly. Default export.
// Features:
// - Real-time simulated WebSocket updates (replaceable with real socket)
// - Interactive list of tasks/users with progress bars
// - Aggregated stats (average, completed count)
// - Search, sort, and filter controls
// - Mini line chart (using simple SVG) showing recent throughput

export default function RealTimeProgressDashboard() {
  // Task shape: { id, user, title, progress (0-100), status, updatedAt }
  const [tasks, setTasks] = useState(initialTasks());
  const [query, setQuery] = useState("");
  const [sortBy, setSortBy] = useState("recent");
  const [onlyActive, setOnlyActive] = useState(false);

  // recent throughput data for mini chart
  const [throughput, setThroughput] = useState(() => generateInitialThroughput());

  // Simulate real-time updates. Replace this effect with your WebSocket / Socket.IO hook.
  useEffect(() => {
    const timer = setInterval(() => {
      setTasks(prev => {
        // pick a random task and mutate progress
        const idx = Math.floor(Math.random() * prev.length);
        const copy = prev.map(t => ({ ...t }));
        const t = copy[idx];
        if (!t) return copy;
        // small random progress jump
        const delta = Math.floor(Math.random() * 20);
        t.progress = Math.min(100, t.progress + delta);
        t.status = t.progress >= 100 ? "completed" : "in-progress";
        t.updatedAt = new Date().toISOString();
        return copy;
      });

      // update throughput: number of completions in last interval (simulated)
      setThroughput(prev => {
        const newPoint = Math.floor(Math.random() * 6); // simulated completions
        const next = [...prev.slice(-19), newPoint];
        return next;
      });
    }, 1400);

    return () => clearInterval(timer);
  }, []);

  // Derived data
  const filtered = useMemo(() => {
    return tasks
      .filter(t => {
        if (onlyActive && t.status === "completed") return false;
        if (!query) return true;
        const q = query.toLowerCase();
        return (
          t.user.toLowerCase().includes(q) ||
          t.title.toLowerCase().includes(q) ||
          t.id.toString().includes(q)
        );
      })
      .sort((a, b) => {
        if (sortBy === "progress") return b.progress - a.progress;
        if (sortBy === "alpha") return a.title.localeCompare(b.title);
        // recent
        return new Date(b.updatedAt) - new Date(a.updatedAt);
      });
  }, [tasks, query, sortBy, onlyActive]);

  const stats = useMemo(() => {
    const total = tasks.length;
    const completed = tasks.filter(t => t.status === "completed").length;
    const avg = Math.round(tasks.reduce((s, t) => s + t.progress, 0) / Math.max(1, total));
    return { total, completed, avg };
  }, [tasks]);

  // Handlers for manual changes (for demo / admin view)
  function bumpTask(id, amount = 10) {
    setTasks(prev => prev.map(t => (t.id === id ? { ...t, progress: Math.min(100, t.progress + amount), status: Math.min(100, t.progress + amount) >= 100 ? "completed" : "in-progress", updatedAt: new Date().toISOString() } : t)));
  }

  function resetAll() {
    setTasks(initialTasks());
    setThroughput(generateInitialThroughput());
  }

  return (
    <div className="p-6 bg-slate-50 min-h-screen font-sans">
      <div className="max-w-6xl mx-auto">
        <header className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-semibold">Real-time Progress Dashboard</h1>
            <p className="text-sm opacity-70">Live updates · Search · Sort · Filters</p>
          </div>

          <div className="flex gap-3 items-center">
            <div className="text-sm text-slate-600">Avg progress: <strong>{stats.avg}%</strong></div>
            <div className="text-sm text-slate-600">Completed: <strong>{stats.completed}/{stats.total}</strong></div>
            <button onClick={resetAll} className="px-3 py-1 rounded-md bg-white border">Reset</button>
          </div>
        </header>

        <section className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Left: controls + chart */}
          <div className="col-span-1 bg-white p-4 rounded-2xl shadow-sm">
            <div className="flex gap-2 items-center mb-3">
              <input value={query} onChange={e => setQuery(e.target.value)} placeholder="Search by user, task or id" className="flex-1 px-3 py-2 rounded-md border" />
              <select value={sortBy} onChange={e => setSortBy(e.target.value)} className="px-3 py-2 rounded-md border">
                <option value="recent">Sort: Recent</option>
                <option value="progress">Sort: Progress</option>
                <option value="alpha">Sort: A–Z</option>
              </select>
            </div>

            <div className="flex items-center gap-3 mb-4">
              <label className="flex items-center gap-2 text-sm">
                <input type="checkbox" checked={onlyActive} onChange={e => setOnlyActive(e.target.checked)} /> Only active
              </label>
            </div>

            <div className="mb-4">
              <h3 className="text-sm font-medium mb-2">Throughput (recent)</h3>
              <MiniSparkline data={throughput} />
            </div>

            <div>
              <h3 className="text-sm font-medium mb-2">Quick actions</h3>
              <div className="flex gap-2">
                <button onClick={() => setTasks(prev => prev.map(t => ({ ...t, progress: Math.min(100, t.progress + 15), status: t.progress + 15 >= 100 ? "completed" : t.status })))} className="px-3 py-2 rounded-md border">Boost all</button>
                <button onClick={() => setTasks(prev => prev.map(t => ({ ...t, progress: Math.max(0, t.progress - 10), status: t.progress - 10 >= 100 ? "completed" : (t.progress - 10 <= 0 ? "pending" : "in-progress") })))} className="px-3 py-2 rounded-md border">Roll back</button>
              </div>
            </div>
          </div>

          {/* Middle: task list */}
          <div className="col-span-1 lg:col-span-2 bg-white p-4 rounded-2xl shadow-sm">
            <div className="overflow-y-auto max-h-[60vh]">
              <ul className="space-y-3">
                {filtered.map(task => (
                  <li key={task.id} className="p-3 rounded-lg border flex items-center justify-between gap-4">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 rounded-full bg-slate-100 flex items-center justify-center text-sm font-medium">{initials(task.user)}</div>
                        <div className="min-w-0">
                          <div className="flex items-center gap-2">
                            <div className="text-sm font-medium truncate">{task.title}</div>
                            <div className="text-xs text-slate-500">by {task.user}</div>
                            <div className="ml-2 text-xs px-2 py-0.5 rounded-full text-white" style={{ backgroundColor: task.status === 'completed' ? '#10b981' : '#3b82f6' }}>{task.status}</div>
                          </div>
                          <div className="mt-2">
                            <div className="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                              <div className="h-2 rounded-full transition-all" style={{ width: `${task.progress}%`, background: progressGradient(task.progress) }} />
                            </div>
                            <div className="text-xs text-slate-500 mt-1">{task.progress}% · updated {timeAgo(task.updatedAt)}</div>
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="flex flex-col items-end gap-2">
                      <button onClick={() => bumpTask(task.id)} className="px-3 py-1 rounded-md border text-sm">+10%</button>
                      <div className="text-xs text-slate-500">#{task.id}</div>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </section>

        <footer className="mt-6 text-sm text-slate-500 text-center">Tip: Replace the simulated updater with your real-time socket to stream progress events.</footer>
      </div>
    </div>
  );
}

// -------------------- Helper components & functions --------------------

function MiniSparkline({ data = [] }) {
  // tiny svg sparkline with bars
  const w = 200;
  const h = 48;
  const barW = w / Math.max(1, data.length);
  const max = Math.max(1, ...data);
  return (
    <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} className="block">
      {data.map((v, i) => {
        const barH = (v / max) * (h - 8);
        return <rect key={i} x={i * barW + 1} y={h - barH - 4} width={barW - 2} height={barH} rx={2} />;
      })}
    </svg>
  );
}

function initialTasks() {
  const users = ["Aisha", "Rohan", "Sam", "Priya", "Kabir", "Mina", "Jai", "Lina"];
  const titles = ["Data labeling", "Model training", "Feature extraction", "Report generation", "QA tests", "Deployment prep", "User onboarding", "Integration tests"];
  return Array.from({ length: 12 }).map((_, i) => {
    const progress = Math.floor(Math.random() * 80);
    return {
      id: 1000 + i,
      user: users[i % users.length],
      title: titles[i % titles.length],
      progress,
      status: progress >= 100 ? "completed" : progress <= 0 ? "pending" : "in-progress",
      updatedAt: new Date(Date.now() - Math.random() * 1000 * 60 * 60).toISOString(),
    };
  });
}

function generateInitialThroughput() {
  return Array.from({ length: 20 }).map(() => Math.floor(Math.random() * 5));
}

function initials(name) {
  return name.split(" ").map(s => s[0]).slice(0, 2).join("").toUpperCase();
}

function timeAgo(iso) {
  const diff = Math.floor((Date.now() - new Date(iso)) / 1000);
  if (diff < 60) return `${diff}s ago`;
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
  return `${Math.floor(diff / 86400)}d ago`;
}

function progressGradient(p) {
  // simple gradient logic: red -> yellow -> green
  if (p < 40) return "linear-gradient(90deg,#ef4444,#f97316)"; // fallback
  if (p < 70) return "linear-gradient(90deg,#f59e0b,#fbbf24)";
  return "linear-gradient(90deg,#10b981,#16a34a)";
}
